<html>
<body>
<div id="container"></div>

<script type="text/javascript" src="lib/script/jquery-2.1.1.min.js" ></script>
<script type="text/javascript" src="lib/script/Stats.js" ></script>
<script type="text/javascript" src="lib/script/three.min.js" ></script>
<script type="text/javascript" src="lib/script/three/FirstPersonControls.js" ></script>

<!- game development with three.js CITY EXAMPLE -->
<script>
	var camera, scene, renderer, controls, clock;

	function setup(){
		document.body.style.backgroundColor = '#d7f0f7';
		setupThreeJS();
		setupWorld();

		requestAnimationFrame(function animate(){
			renderer.render(scene, camera);
			controls.update(clock.getDelta());
			requestAnimationFrame(animate);
		});
	};

	function setupThreeJS(){
		scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.y = 600;
		camera.position.z = 600;
		camera.rotation.x = -45 * Math.PI / 180;

		clock = new THREE.Clock(  );

		controls = new THREE.FirstPersonControls( camera );
		controls.movementSpeed = 100;
		controls.lookSpeed = 0.1;

		renderer = new THREE.WebGLRenderer( );
		renderer.shadowMapEnabled = true;
		renderer.shadowMapSoft = true;
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);
	};

	function setupWorld(){
		//Floor
		var geo = new THREE.PlaneGeometry( 2000, 2000, 20, 	20 );
		var mat = new THREE.MeshBasicMaterial( {color: 0x9db3b5, overdraw: true} );
		var floor = new THREE.Mesh(geo, mat);
		floor.rotation.x = -90 * Math.PI / 180;
		scene.add(floor);

		//Original building
		var geometry = new THREE.CubeGeometry(1,1,1);
		geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, 0));
		var material = new THREE.MeshPhongMaterial({overdraw: true, color: 0xcccccc});

		//Cloned buildings
		var cityGeometry = new THREE.Geometry();
		for (var i = 0; i < 300; i++) {
			var building = new THREE.Mesh(geometry.clone());
			building.position.x = Math.floor(Math.random() * 200 - 100) * 4;
			building.position.z = Math.floor(Math.random() * 200 - 100) * 4;
			building.scale.x = Math.random() * 50 + 10;
			building.scale.y = Math.random() * building.scale.x * 8 + 8;
			building.scale.z = building.scale.x;
			THREE.GeometryUtils.merge(cityGeometry, building);
		}
		var city = new THREE.Mesh(cityGeometry, material);
		scene.add(city);

		//Light
		var light = new THREE.DirectionalLight( 0xf6e86d, 1 );
		light.position.set(1, 3, 2);
		light.castShadow = true;
		light.shadowDarkness = 0.5;
		light.shadowMapWidth = 2048;
		light.shadowMapHeight = 2048;
		light.position.set(500, 1500, 1000);
		light.shadowCameraFar = 2500;
		//directionalLight only: not necessary for Pointlight
		light.shadowCameraLeft = -1000;
		light.shadowCameraRight = 1000;
		light.shadowCameraTop = 1000;
		light.shadowCameraBottom = -1000;
		scene.add(light);

		//Fog
		scene.fog = new THREE.FogExp2( 0x9db3b5, 0.002 );

		//Shadows
		floor.receiveShadow = true;
		city.castShadow = true;
		city.receiveShadow = true;

		//Interaction
		/*projector = THREE.Projector();
		renderer.domElement.addEentListener('mousedown', function(event){
			var vector = new THREE.Vector3( renderer.devicePixelRatio * (event.pageX - this.offsetLeft) / this.width * 2 - 1,
											-renderer.devicePixelRatio * (event.pageY - this.offsetTop) / this.height * 2 - 1,
											0);
			projector.unprojectVector(vector, camera);
			var raycaster = THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
			var intersects = raycaster.intersectObjects(OBJECTS);
			if(intersects.length){
				//intersects[0] describes the clicked object
			}
		}, false);
		var widthHalf = 0.5 * renderer.domElement.width / renderer.devicePixelRatio,
		heightHalf = 0.5 * renderer.domElement.height / renderer.devicePixelRatio;

		var vector = mesh.position.clone(); // or an arbritrary point
		projector.projectVector(vector, camera);

		vector.x = vector.x * widthHalf + widthHalf;
		vector.y = -vector.y * heightHalf + heightHalf;*/
	};

	//Run it!
	setup();
</script>

</body> 
</html>