<html>
<body>
<div id="container"></div>

<script type="text/javascript" src="lib/script/jquery-2.1.1.min.js" ></script>
<script type="text/javascript" src="lib/script/Stats.js" ></script>
<script type="text/javascript" src="lib/script/three.min.js" ></script>
<script type="text/javascript" src='lib/script/threex/keyboardstate/threex.keyboardstate.js'></script>
<script type="text/javascript" src='lib/script/threex/skymap/threex.skymap.js'></script>
<script type="text/javascript" src='lib/script/threex/skymap/threex.texturecube.js'></script>
<script type="text/javascript" src='lib/script/threex/skymap/threex.cubetexturehcross.js'></script>

<script>
	var $container, scene, camera, renderer, controls, stats, skybox;
	var shots = [];
	var keyboard = new THREEx.KeyboardState();
	var clock = new THREE.Clock();
	var shotlife = 10;

	init();
	animate();
	
	function init(){
		// set some constants
	 	var VIEW_DISTANCE = 5000;

	    // set the scene size
		var WIDTH = 480,
		    HEIGHT = 320;

		// set some camera attributes
		var VIEW_ANGLE = 45,
		    ASPECT = WIDTH / HEIGHT,
		    NEAR = 0.1,
		    FAR = VIEW_DISTANCE*2;

		// get the DOM element to attach to
		// - assume we've got jQuery to hand
		$container = $('#container');

		// create a WebGL renderer, camera
		// and a scene
		renderer = new THREE.WebGLRenderer({antialias:true});
		camera = new THREE.PerspectiveCamera(
		                   VIEW_ANGLE,
		                   ASPECT,
		                   NEAR,
		                   FAR );

		scene = new THREE.Scene();

		// start the renderer
		renderer.setSize(WIDTH, HEIGHT);

		// attach the render-supplied DOM element
		$container.append(renderer.domElement);

		//AXIS
		var X_AXIS = buildAxis(
		    new THREE.Vector3( 0, 0, 0 ),
		    new THREE.Vector3( VIEW_DISTANCE, 0, 0 ),
		    0xFF0000,
		    true
		);

		var Y_AXIS = buildAxis(
		    new THREE.Vector3( 0, 0, 0 ),
		    new THREE.Vector3( 0, VIEW_DISTANCE, 0 ),
		    0x00FF00,
		    true
		);

		var Z_AXIS = buildAxis(
		    new THREE.Vector3( 0, 0, 0 ),
		    new THREE.Vector3( 0, 0, VIEW_DISTANCE ),
		    0x0000FF,
		    true
		);

		scene.add( X_AXIS );
		scene.add( Y_AXIS );
		scene.add( Z_AXIS );

		// STATS
		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.bottom = '0px';
		stats.domElement.style.zIndex = 100;
		container.appendChild( stats.domElement );

		// LIGHT
		var light = new THREE.PointLight(0xffffff);
		light.position.set(0,250,0);
		scene.add(light);

		// FLOOR
		var floorTexture = new THREE.ImageUtils.loadTexture( 'lib/resources/dirt.jpg' );
		floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
		floorTexture.repeat.set( 50, 50 );

		var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
		var floorGeometry = new THREE.PlaneBufferGeometry (VIEW_DISTANCE, VIEW_DISTANCE, 50, 50);
		var floor = new THREE.Mesh(floorGeometry, floorMaterial);
		floor.position.y = -0.5;
		floor.rotation.x = Math.PI / 2;
		scene.add(floor);

		// SKYBOX/FOG
		skybox = THREEx.createSkymap({
			textureCube: THREEx.createTextureCube('mars'), 
			cubeW: VIEW_DISTANCE, 
			cubeH: VIEW_DISTANCE, 
			cubeD: VIEW_DISTANCE
		});
		scene.add( skybox );

		////////////
		// CUSTOM //
		////////////
		
		// create an array with six textures for a cool cube
		var materialArray = [];
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'lib/resources/xpos.png' ) }));
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'lib/resources/xneg.png' ) }));
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'lib/resources/ypos.png' ) }));
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'lib/resources/yneg.png' ) }));
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'lib/resources/zpos.png' ) }));
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'lib/resources/zneg.png' ) }));

		var loader = new THREE.JSONLoader();
		loader.load("/lib/resources/pistol/Pistol.js", function ( geometry ) {
 	 		
 	 		var material = new THREE.MeshBasicMaterial( {map: THREE.ImageUtils.loadTexture( "lib/resources/pistol/Pistol.jpg" ), shading: THREE.NoShading, color: 0xffffff, morphTargets: true } );

	  	Pistol = new THREE.MorphAnimMesh( geometry, material );
			Pistol.rotation.y = - (Math.PI / 2);
			Pistol.scale.set(.5,.5,.5);
			Pistol.position.set(25, 100, 0);
			Pistol.castShadow = true;
			Pistol.receiveShadow = false;
		});

		loader.onLoadComplete = function(){
			console.log("LOAD COMPLETE!")
			scene.add( Pistol );
		} 

		//Wireframe
		var MovingCubeMat = new THREE.MeshBasicMaterial( { color: 0x00ee00, wireframe: false, transparent: true } );
		var MovingCubeGeom = new THREE.BoxGeometry(50, 50, 50);
		MovingCube = new THREE.Mesh( MovingCubeGeom, MovingCubeMat );
		MovingCube.position.set(0, 100, 0);
		scene.add( MovingCube );
	};

	function animate() 
	{
    requestAnimationFrame( animate );
		render();		
		update();
	};

	function update()
	{
		var delta = clock.getDelta(); // seconds.
		var moveDistance = 200 * delta; // 200 pixels per second
		var rotateAngle = Math.PI / 2 * delta;   // pi/2 radians (90 degrees) per second
		
		// local transformations

		// move forwards/backwards/left/right
		if ( keyboard.pressed("W") ){
			MovingCube.translateZ( -moveDistance );
		}
		if ( keyboard.pressed("S") ){
			MovingCube.translateZ(  moveDistance );
		}

		if ( keyboard.pressed("Q") )
			MovingCube.translateX( -moveDistance );
		if ( keyboard.pressed("E") )
			MovingCube.translateX(  moveDistance );	

		// rotate left/right/up/down
		var rotation_matrix = new THREE.Matrix4().identity();
		if ( keyboard.pressed("A") ){
			MovingCube.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle);
			if(typeof(Pistol) !== "undefined"){
				Pistol.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle);
			}
		}
		if ( keyboard.pressed("D") ){
			MovingCube.rotateOnAxis( new THREE.Vector3(0,1,0), -rotateAngle);
			if(typeof(Pistol) !== "undefined"){
				Pistol.rotateOnAxis( new THREE.Vector3(0,1,0), -rotateAngle);
			}
		}
		if ( keyboard.pressed("R") )
			MovingCube.rotateOnAxis( new THREE.Vector3(1,0,0), rotateAngle);
		if ( keyboard.pressed("F") )
			MovingCube.rotateOnAxis( new THREE.Vector3(1,0,0), -rotateAngle);
		
		if ( keyboard.pressed("Z") )
		{
			MovingCube.position.set(0,25.1,0);
			MovingCube.rotation.set(0,0,0);
		}

		if (keyboard.pressed("space"))
		{
			
			if(shots.length === 0)
			{
				//Bullet
				var BulletMat = new THREE.MeshBasicMaterial( 
					{ color: 0xff0000, wireframe: false, transparent: true } 
				);
				var BulletGeom = new THREE.BoxGeometry(5, 5, 5);
				var Bullet = new THREE.Mesh( BulletGeom, BulletMat );
				//Bullet.position.set(
				//	Pistol.position.x, 
				//	Pistol.position.y - 25, 
				//	Pistol.position.z - 170
				//);
				Bullet.position.set(
					Pistol.position.x, 
					Pistol.position.y - 25, 
					Pistol .position.z
				);
				scene.add( Bullet );
				shots.push( Bullet );
			}

		}
		
		var relativeCameraOffset = new THREE.Vector3(0,0,1);

		var cameraOffset = relativeCameraOffset.applyMatrix4( MovingCube.matrixWorld );

		camera.position.x = cameraOffset.x;
		camera.position.y = cameraOffset.y;
		camera.position.z = cameraOffset.z;
		camera.lookAt( MovingCube.position );
		
		if(typeof(Pistol) !== "undefined"){
			Pistol.position.set(MovingCube.position.x, MovingCube.position.y, MovingCube.position.z);
		}

		if(shots.length > 0){
				var pLocal = new THREE.Vector3( 0, 0, -1 );
				var pWorld = pLocal.applyMatrix4( camera.matrixWorld );
				var dir = pWorld.sub( camera.position ).normalize();

				shots[0].translateOnAxis(dir, 50);
				shotlife -= 1;
				if(shotlife === 0){
					//scene.remove(shots[0]);
					shots = [];
					shotlife = 10;
				}
				//console.log(scene);
				//shots = [];
		}
		//camera.updateMatrix();
		//camera.updateProjectionMatrix();
		stats.update();
	};

	function render() 
	{
		renderer.render( scene, camera );
	}

	function buildAxis( src, dst, colorHex, dashed ) {
        var geom = new THREE.Geometry(),
            mat; 

        if(dashed) {
                mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3 });
        } else {
                mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });
        }

        geom.vertices.push( src.clone() );
        geom.vertices.push( dst.clone() );
        geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

        var axis = new THREE.Line( geom, mat, THREE.LinePieces );

        return axis;

	}
</script>
</body> 
</html>